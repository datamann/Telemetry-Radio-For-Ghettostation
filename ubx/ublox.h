/*
 * Written by Stig B. Sivertsen
 * sbsivertsen@gmail.com
 * https://github.com/datamann/GPSConfigurator
 * 11.09.2019
 * @see The GNU Public License (GPL) Version 3
*/

void turnOffNMEA(){
  #ifdef DEBUG
    Serial.print(F("Switching off all NMEA packets: "));
  #endif  
  uint8_t setALLOff[] = {0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x00,0x00,0xFA,0x0F, //(GxGGA)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x01,0x00,0xFB,0x11, //(GxGLL)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x02,0x00,0xFC,0x13, //(GxGSA)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x03,0x00,0xFD,0x15, //(GxGSV)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x04,0x00,0xFE,0x17, //(GxRMC)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x05,0x00,0xFF,0x19, //(GxVTG)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x0A,0x00,0x04,0x23, //(GxDTM)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x09,0x00,0x03,0x21, //(GxGBS)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x0D,0x00,0x07,0x29, //(GxGNS)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x06,0x00,0x00,0x1B, //(GxGRS)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x07,0x00,0x01,0x1D, //(GxGST)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x0F,0x00,0x09,0x2D, //(GxVLW)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF0,0x08,0x00,0x02,0x1F, //(GxZDA)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF1,0x00,0x00,0xFB,0x12, //(PUBX-00)
                         //0xB5,0x62,0x06,0x01,0x03,0x00,0xF1,0x01,0x00,0xFC,0x14, //(PUBX-01) Failed on Beitian BN-880
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF1,0x03,0x00,0xFE,0x18, //(PUBX-03)
                         0xB5,0x62,0x06,0x01,0x03,0x00,0xF1,0x04,0x00,0xFF,0x1A  //(PUBX-04)
                         //0xB5,0x62,0x06,0x01,0x03,0x00,0xF1,0x05,0x00,0x00,0x1C, //(PUBX-05) Failed on Beitian BN-880
                         //0xB5,0x62,0x06,0x01,0x03,0x00,0xF1,0x06,0x00,0x01,0x1E  //(PUBX-06) Failed on Beitian BN-880
                        };
  sendUBX(setALLOff, sizeof(setALLOff)/sizeof(uint8_t));
  getUBX_ACK(setALLOff);
}

void turnOnUBXGhettostation()
{
  turnOffNMEA();
  /*Ghettostation
    Active messages : 
    NAV-POSLLH Geodetic Position Solution, PAGE 66 of datasheet
    NAV-VELNED Velocity Solution in NED, PAGE 71 of datasheet
    NAV-STATUS Receiver Navigation Status
      or 
    NAV-SOL Navigation Solution Information*/

  #ifdef DEBUG
    Serial.print(F("Switching on UBLOX needed for Ghettostation: "));
  #endif 
  uint8_t setUBXOn[] = {//0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x02,0x01,0x0E,0x47, //NAV-POSLLH on
                        //0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x03,0x01,0x0F,0x49, //NAV-STATUS on
                        //0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x06,0x01,0x12,0x4F, //NAV-SOL on
                        0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x12,0x01,0x1E,0x67  //NAV-VELNED on
                        };
  sendUBX(setUBXOn, sizeof(setUBXOn)/sizeof(uint8_t));
  getUBX_ACK(setUBXOn);  
}

void turnOnUBX()
{
  turnOffNMEA();
   // Enable UBX
  #ifdef DEBUG
    Serial.print(F("Switching on UBLOX: "));
  #endif 
  uint8_t setUBXOn[] = {0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x07,0x01,0x13,0x51, //NAV-PVT on
                        0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x02,0x01,0x0E,0x47, //NAV-POSLLH on
                        0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x03,0x01,0x0F,0x49, //NAV-STATUS on
                        0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x04,0x01,0x10,0x4B, //NAV-DOP on
                        0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x06,0x01,0x12,0x4F, //NAV-SOL on
                        0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x12,0x01,0x1E,0x67  //NAV-VELNED on
                        };
  sendUBX(setUBXOn, sizeof(setUBXOn)/sizeof(uint8_t));
  getUBX_ACK(setUBXOn);  
}

void turnOffUBX()
{
  #ifdef DEBUG
    Serial.print(F("Switching off UBLOX: "));
  #endif  
  uint8_t setUBXOff[] = {0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x07,0x00,0x12,0x50,  //NAV-PVT off
                         0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x02,0x00,0x0D,0x46,  //NAV-POSLLH off
                         0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x03,0x00,0x0E,0x48,  //NAV-STATUS off
                         0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x04,0x00,0x0F,0x4A,  //NAV-DOP off
                         0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x06,0x00,0x11,0x4E,  //NAV-SOL off
                         0xB5,0x62,0x06,0x01,0x03,0x00,0x01,0x12,0x00,0x1D,0x66   //NAV-VELNED off
                         };
  sendUBX(setUBXOff, sizeof(setUBXOff)/sizeof(uint8_t));
  getUBX_ACK(setUBXOff);  
}

 // Set the navigation mode (Airborne, 1G)
  /*Serial.print("Setting uBlox nav mode: ");
  uint8_t setNav[] = {0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x06,0x03,0x00,0x00,0x00,
                      0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,
                      0x2C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x16,0xDC
                      };
  sendUBX(setNav, sizeof(setNav)/sizeof(uint8_t));
  getUBX_ACK(setNav);*/ 

  

 

// Function to poll the NAV5 status of a Ublox GPS module (5/6)
// Sends a UBX command (requires the function sendUBX()) and waits 3 seconds
// for a reply from the module. The then isolates the byte which contains 
// the information regarding the NAV5 mode,
// 0 = Pedestrian mode (default, will not work above 12km)
// 6 = Airborne 1G (works up to 50km altitude)
// Adapted by jcoxon from getUBX_ACK() from the example code on UKHAS wiki
// http://wiki.ukhas.org.uk/guides:falcom_fsa03
/*boolean checkNAV(){
  uint8_t b, bytePos = 0;
  uint8_t getNAV5[] = { 0xB5, 0x62, 0x06, 0x24, 0x00, 0x00, 0x2A, 0x84 }; //Poll NAV5 status
 
  gps.flush();
  unsigned long startTime = millis();
  sendUBX(getNAV5, sizeof(getNAV5)/sizeof(uint8_t));
 
  while (1) {
    // Make sure data is available to read
    if (gps.available()) {
      b = gps.read();
 
      if(bytePos == 8){
        navmode = b;
        return true;
      }
 
      bytePos++;
    }
    // Timeout if no valid response in 3 seconds
    if (millis() - startTime > 3000) {
      navmode = 0;
      return false;
    }
  }
}*/
  
